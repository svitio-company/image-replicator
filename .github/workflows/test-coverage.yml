name: Test Coverage

on:
  pull_request:
    branches: [main]
  push:
    branches: [main]

jobs:
  coverage:
    name: Check Test Coverage
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
      issues: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: latest

      - name: Install dependencies
        run: bun install --frozen-lockfile

      - name: Run tests with coverage
        id: coverage
        run: |
          bun test --coverage > coverage-output.txt 2>&1 || echo "COVERAGE_FAILED=true" >> $GITHUB_OUTPUT
          cat coverage-output.txt
          
          # Extract coverage percentages
          FUNC_COV=$(grep "All files" coverage-output.txt | awk '{print $2}' | tr -d '%')
          LINE_COV=$(grep "All files" coverage-output.txt | awk '{print $3}' | tr -d '%')
          
          echo "function_coverage=$FUNC_COV" >> $GITHUB_OUTPUT
          echo "line_coverage=$LINE_COV" >> $GITHUB_OUTPUT
          
          # Extract file-by-file coverage
          awk '/File.*% Funcs.*% Lines/,/---------/ {
            if ($0 ~ /^---------/) next;
            if ($0 ~ /File.*% Funcs/) next;
            if ($0 ~ /All files/) next;
            if (NF > 0) print
          }' coverage-output.txt > file-coverage.txt
          
          cat file-coverage.txt
          
          # Re-run coverage to check threshold (will exit with proper code)
          bun test --coverage

      - name: Comment coverage on PR
        if: github.event_name == 'pull_request' && always()
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const funcCov = '${{ steps.coverage.outputs.function_coverage }}';
            const lineCov = '${{ steps.coverage.outputs.line_coverage }}';
            const failed = '${{ steps.coverage.outputs.COVERAGE_FAILED }}' === 'true';
            
            const threshold = 80;
            const funcPass = parseFloat(funcCov) >= threshold;
            const linePass = parseFloat(lineCov) >= threshold;
            const overallPass = funcPass && linePass && !failed;
            
            const icon = overallPass ? '✅' : '❌';
            const status = overallPass ? 'PASSED' : 'FAILED';
            
            // Read file coverage details
            let fileCoverage = '';
            try {
              const fileContent = fs.readFileSync('file-coverage.txt', 'utf8');
              if (fileContent.trim()) {
                fileCoverage = '\n### Coverage by File\n\n```\n' + fileContent + '```\n';
              }
            } catch (e) {
              console.log('No file coverage data available');
            }
            
            const comment = `## ${icon} Test Coverage Report
            
            **Status:** ${status}
            
            | Metric | Coverage | Threshold | Status |
            |--------|----------|-----------|--------|
            | Functions | ${funcCov}% | ${threshold}% | ${funcPass ? '✅' : '❌'} |
            | Lines | ${lineCov}% | ${threshold}% | ${linePass ? '✅' : '❌'} |
            ${fileCoverage}
            ${overallPass ? 
              '✅ **All coverage thresholds met!**' : 
              '❌ **Coverage is below the minimum threshold.** Please add more tests.'
            }
            
            ---
            <sub>Run \`bun test --coverage\` locally to see detailed coverage report.</sub>
            `;
            
            // Find existing coverage comments
            const comments = await github.rest.issues.listComments({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
            });
            
            const botComment = comments.data.find(comment => 
              comment.user.type === 'Bot' && 
              comment.body.includes('Test Coverage Report')
            );
            
            if (botComment) {
              // Update existing comment
              await github.rest.issues.updateComment({
                comment_id: botComment.id,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: comment
              });
            } else {
              // Create new comment
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: comment
              });
            }
